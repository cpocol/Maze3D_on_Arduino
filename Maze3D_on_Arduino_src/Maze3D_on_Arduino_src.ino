//#define USE_I2C //as opposed to SPI

#include "Config.h"
#include "Controller.h"
#include "LUTs.h"
#include "Map.h"
#include "Texture.h"
#include "acceleratedMotion.h" // generated by "Generate acceleratedMotion.cpp" (run it with CodeBlocks)
#include "main.h"

#define sq(x) ((x)*(x))

#ifdef USE_I2C
  #include "I2C_Adafruit_SSD1306.h"
  I2C_Adafruit_SSD1306 display(screenW, screenH);
#else
  #include "SPI_Adafruit_SSD1306.h"
  // Arduino Mega default SPI pins:
  // 50(CIPO) - not used for SSD1306
  // 51(COPI)
  // 52(SCK)
  #define OLED_RESET   5
  #define OLED_DC      4
  #define OLED_CS      3
SPI_Adafruit_SSD1306 display(screenW, screenH, OLED_DC, OLED_RESET, OLED_CS, 8000000UL);
#endif

const int screenSize = screenW * ((screenH + 7) / 8);
uint8_t screen[screenSize];

const int16_t mapSizeHeight = mapHeight * sqRes, mapSizeWidth = mapWidth * sqRes;
const fptype mapSizeWidth_fp = (((fptype)mapSizeWidth) << fp), mapSizeHeight_fp = (((fptype)mapSizeHeight) << fp);

//initial
int32_t xC = 1.5 * sqRes;
int32_t yC = 1.5 * sqRes;
int16_t angleC = 80;
int elevation_perc = 0; //as percentage from wall half height

int8_t xCMap = xC >> sqRes_pow2;
int8_t yCMap = yC >> sqRes_pow2;

fptype xC_fp = (fptype)xC << fp;
fptype yC_fp = (fptype)yC << fp;

void setup() {
    Serial.begin(250000);

    display.setBuffer(screen);
    if(!display.begin()) {
        Serial.println(F("!SSD1306"));
        for(;;); // Don't proceed, loop forever
    }

    initController();
    // Serial.println("ROM");
    // Serial.print("Tan sizeof: ");   Serial.println(sizeof(Tan_fp));
    // Serial.print("CTan sizeof: ");   Serial.println(sizeof(CTan_fp));
    // Serial.print("Map size (W x H), sizeof: ");   Serial.print(mapWidth);   Serial.print(" x ");   Serial.print(mapHeight);   Serial.print(", ");   Serial.println(sizeof(Map));
    // Serial.print("acceleratedMotion sizeof: ");   Serial.println(sizeof(acceleratedMotion));
    // Serial.print("Texture size, sizeof: ");   Serial.print(texRes);   Serial.print(", ");   Serial.println(sizeof(Texture));
    // Serial.println("RAM");
    // Serial.print("TwoWire sizeof: ");   Serial.println(sizeof(*(display.wire)));
    // Serial.print("Screen sizeof: ");   Serial.println(sizeof(screen));
}

TCastResponse_fp CastX(int16_t angle) { // hit vertical walls ||
    TCastResponse_fp result;
    result.xHit_fp = 1000000000;
    if ((angle == aroundq) || (angle == around3q))
        return result; // CastY() will hit a wall correctly

    // prepare as for 1st or 4th quadrant (looking estward)
    result.xMap = xCMap + 1;
    int8_t dxMap = 1,    adjXMap = 0;
    fptype tan_fp = (fptype) pgm_read_dword_near(Tan_fp + angle / screenW_lowResFactor);
    fptype dy_fp = tan_fp << sqRes_pow2;
    if ((aroundq < angle) && (angle < around3q)) { // 2nd or 3rd quadrant
        result.xMap--;
        dxMap = -1;
        adjXMap = -1;
        dy_fp = -dy_fp;
    }
    result.yHit_fp = yC_fp + ((result.xMap << sqRes_pow2) - xC) * tan_fp;

    result.xMap += adjXMap;
    result.yMap = result.yHit_fp >> (sqRes_pow2 + fp);
    while ((0 < result.yHit_fp) && (result.yHit_fp < mapSizeHeight_fp) && //(0 < result.xMap) && (result.xMap < mapWidth) && //works much slower without checking x, although it shouldn't be done if the map is well closed
           (MAP(result.yMap, result.xMap) == 0)) {
        result.yHit_fp += dy_fp;
        result.xMap += dxMap;
        result.yMap = result.yHit_fp >> (sqRes_pow2 + fp);
    }

    result.xHit_fp = fptype(result.xMap - adjXMap) << (sqRes_pow2 + fp);

    return result;
}

TCastResponse_fp CastY(int16_t angle) { // hit horizontal walls ==
    TCastResponse_fp result;
    result.xHit_fp = 1000000000;
    if ((angle == 0) || (angle == aroundh))
        return result; // CastX() will hit a wall correctly

    // prepare as for 1st or 2nd quadrant (lookog southward)
    result.yMap = yCMap + 1;
    int8_t dyMap = 1,    adjYMap = 0;
    fptype ctan_fp = (fptype) pgm_read_dword_near(CTan_fp + angle / screenW_lowResFactor);
    fptype dx_fp = ctan_fp << sqRes_pow2;
    if (angle > aroundh) { // 3rd or 4th quadrants (looking northward)
        result.yMap--;
        dyMap = -1;
        adjYMap = -1;
        dx_fp = -dx_fp;
    }
    result.xHit_fp = xC_fp + ((result.yMap << sqRes_pow2) - yC) * ctan_fp;

    result.yMap += adjYMap;
    result.xMap = result.xHit_fp >> (sqRes_pow2 + fp);
    while ((0 < result.xHit_fp) && (result.xHit_fp < mapSizeWidth_fp) && //(0 < result.yMap) && (result.yMap < mapHeight) && //works much slower without checking y, although it shouldn't be done if the map is well closed
           (MAP(result.yMap, result.xMap) == 0)) {
        result.xHit_fp += dx_fp;
        result.yMap += dyMap;
        result.xMap = result.xHit_fp >> (sqRes_pow2 + fp);
    }

    result.yHit_fp = fptype(result.yMap - adjYMap) << (sqRes_pow2 + fp);

    return result;
}

TCastResponse Cast(int16_t angle) {
    TCastResponse_fp resultX = CastX(angle);
    TCastResponse_fp resultY = CastY(angle);
    // choose the nearest hit point
    if (abs(xC_fp - resultX.xHit_fp) < abs(xC_fp - resultY.xHit_fp)) // vertical wall ||
        return {int16_t(resultX.xHit_fp >> fp), int16_t(resultX.yHit_fp >> fp), resultX.xMap, resultX.yMap, 0};
    else // horizontal wall ==
        return {int16_t(resultY.xHit_fp >> fp), int16_t(resultY.yHit_fp >> fp), resultY.xMap, resultY.yMap, 1};
}

void RenderColumn(int16_t col, int32_t h, int8_t textureColumn) {
    uint32_t Dh_fp = ((uint32_t)texRes << 16) / h; // 1 row in screen space is this many rows in texture space; use fixed point; 8 is not enough
    uint32_t textureRow_fp = 0;
    //int minRow = screenHh - h / 2; // no elevation
    int16_t minRow = ((100 - elevation_perc) * (2 * screenHh - h) / 2 + elevation_perc * screenHh) / 100;
    int8_t maxRow = min(minRow + h, screenH);

    if (minRow < 0) { // clip
        textureRow_fp = uint32_t(-minRow) * Dh_fp;
        minRow = 0;
    }

    uint16_t textureOffsetInit = (uint16_t)textureColumn << texRes_pow2; // huge speedup: 90 degs pre-rotated texture
#ifndef TEXTURE_1bpp
    const unsigned char* pTexture = Texture + textureOffsetInit;
#endif
    uint8_t row = minRow;
    uint8_t pixelPack = 0;
    uint8_t pixelBit = row & 7;
    unsigned char* pScreenPixelPack = screen + col + (row / 8) * screenW;
    for (; row < maxRow; row++) {
#ifdef TEXTURE_1bpp // configured in "Generate Texture.cpp"
        uint16_t textureOffset = textureOffsetInit + uint16_t(textureRow_fp >> 16);
        uint16_t textureOffsetByte = textureOffset / 8;
        uint8_t textureOffsetBit = uint8_t(textureOffset) & 7;

        unsigned char pixelByte = *(Texture + textureOffsetByte);
        //unsigned char pixelByte = pgm_read_byte_near(Texture + textureOffsetByte);
        unsigned char pixel = (pixelByte >> textureOffsetBit) & 1;
#else
        unsigned char pixel = pTexture[uint16_t(textureRow_fp >> 16)];
#endif

        pixelPack |= (pixel << pixelBit);
        pixelBit++;
        if (pixelBit == 8)
        {
            *pScreenPixelPack = pixelPack;
            pScreenPixelPack += screenW;
            pixelPack = 0;
            pixelBit = 0;
        }

        textureRow_fp += Dh_fp;
    }

    if (pixelBit != 0)
        *pScreenPixelPack = pixelPack;
}

void Render() {
    static long t_prev = millis();
    long t0 = millis();
    memset(screen, 0, screenSize);
    long t1 = millis();   int dt_clear = int(t1 - t0);   t0 = t1;

    for (int16_t col = 0; col < screenW; col++) {
        int16_t ang = (screenWh - col + angleC + around) % around;
        TCastResponse result = Cast(ang);

        uint8_t textureColumn = ((result.xHit + result.yHit) & sqRes_LSBmask) >> (sqRes_pow2 - texRes_pow2); //suppose sqRes_pow2 >= texRes_pow2

        int32_t dist_sq = sq(xC - result.xHit) + sq(yC - result.yHit) + 1; // +1 avoids division by zero
        dist_sq = dist_sq * 2; // adjust until it looks fine; the smaller this one, the taller the walls
        int32_t h = int32_t(sqRes_f * sqrtf((viewerToScreen_sq + sq(screenWh - col)) / (float)dist_sq));

        RenderColumn(col, h, textureColumn);
    }
    t1 = millis();   int dt_render = int(t1 - t0);   t0 = t1;

    // mirror image; we need this because the map's CS is left handed while the ray casting works right handed
    for (int r = 0; r < (screenH + 7) / 8; r++)
        for (int col = 0; col < screenWh; col++) {
            int8_t aux = *(screen + r * screenW + col);
            *(screen + r * screenW + col) = *(screen + r * screenW + screenW - 1 - col);
            *(screen + r * screenW + screenW - 1 - col) = aux;
        }
    t1 = millis();   int dt_mirror = int(t1 - t0);   t0 = t1;

    display.flush();
    t1 = millis();   int dt_flush = int(t1 - t0);   t0 = t1;

    float FPS = 1000.f / (t1 - t_prev);
    // Serial.print(F("     Clear: "));    Serial.print(dt_clear);
    Serial.print(F("     Render: "));   Serial.print(dt_render);
    //Serial.print(F("     Mirror: "));   Serial.print(dt_mirror);
    Serial.print(F("     Send to screen: "));    Serial.print(dt_flush);
    Serial.print(F("     FPS: "));         Serial.print(FPS);
    Serial.println("");
    t_prev = millis();
}

void loop() {
    Render();
    loopController(xC, yC, angleC, around);
}
